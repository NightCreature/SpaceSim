//uniform vec3 spotpos;
uniform vec3 pointpos;
uniform sampler2D tex;
uniform sampler2D tex2;

varying vec3 position;
varying vec3 normal;
varying float constatt, linatt, quadatt;
varying vec2 texcoords0, texcoords1;
varying vec3 tspos, tppos;
   
vec4 pointLight(in int lightnumber)
{
   vec4 diffuse;
   vec3 norm = normalize(normal);
   vec3 lightVector = tppos - position;
   float dist = length(lightVector);
   float attenuation = 1.0 / (constatt + linatt * dist + quadatt * dist * dist);
   lightVector = normalize(lightVector);
   float nxDir = max(0.0, dot(norm, lightVector));
   diffuse = gl_FrontMaterial.diffuse * gl_LightSource[lightnumber].diffuse * nxDir * attenuation;
   vec4 ambientcolor = (gl_FrontLightModelProduct.sceneColor * gl_FrontMaterial.ambient) + 
                (gl_LightSource[lightnumber].ambient * gl_FrontMaterial.ambient);
   return (diffuse + ambientcolor);
}

vec4 spotLight(in int lightnumber)
{
//varying vec3 position;
//varying vec3 normal;
//varying float constatt, linatt, quadatt;
//varying vec2 texcoords0, texcoords1;

   vec3 norm = normalize(normal);
   //Calculate vector from light to pixel being colored
   vec3 D = vec3(gl_LightSource[lightnumber].position) - position;
   //Calculate length from this vector for attentuation use
   float dist = length(D);
   //Normalize it
   lightVector = normalize(D);
   //Take the dot product between D and the LightDirection
   float cosalpha = max(0.0, dot(norm, D));
   
   //Temp color and attenuation factor
   vec4 diffuse;
   float attenuation = 1.0 / (constatt + linatt * dist + quadatt * dist * dist);
   if (cosalpha > 0.0) {
   
      float spotEffect = dot(normalize(gl_LightSource[lightnumber].spotDirection), 
            cosalpha);
	//If the cosine from NdotD is bigger than the spotCutoffCosine we are in the outercone of the light     
      if (cosalpha > gl_LightSource[lightnumber].spotCosCutoff) 
      {
		//Calculate the spoteffect and multiply it with the attenuation
      		spotEffect = pow(spotEffect, gl_LightSource[lightnumber].spotExponent);
     		attenuation *= spotEffect;
      }
   }
   //Add diffuse color to this pixel
   diffuse += attenuation * (diffuse * cosalpha);
   //calculate the ambient factor
   vec4 ambientcolor = (gl_FrontLightModelProduct.sceneColor * gl_FrontMaterial.ambient) + 
                (gl_LightSource[lightnumber].ambient * gl_FrontMaterial.ambient);
   //Final light color for this pixel is the ambient + the diffuse color + other light colors
   return (diffuse + ambientcolor);
}

vec4 modulateTextures()
{
    return(texture2D(tex2, texcoords1) * texture2D(tex, texcoords0));
}

void main()
{
    //gl_LightModel.ambient is the global ambient light
    gl_FragColor = gl_LightModel.ambient +/*modulateTextures() * (spotLight(0) + */pointLight(1);
}

