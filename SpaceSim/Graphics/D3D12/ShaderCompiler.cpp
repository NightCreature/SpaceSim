#include "Graphics\D3D12\ShaderCompiler.h"

#include "Core/Profiler/ProfilerMacros.h"
#include "Core\StringOperations\StringHelperFunctions.h"
#include "Logging/LoggingMacros.h"


#include <combaseapi.h>
#include <string>
#include "..\Shaders.h"
#include <ios>
#include "Core\FileSystem\FileSystem.h"
#include "Core\Resource\Resourceable.h"
#include <filesystem>


///-----------------------------------------------------------------------------
///! @brief   
///! @remark
///-----------------------------------------------------------------------------
bool ShaderCompiler::Initialise(Resource* resource)
{
    m_resource = resource;

    HRESULT hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&m_dxcUtils));
    if (FAILED(hr))
    {
        MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to initialise Dxc Library intergace");
        return false;
    }


    hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&m_compiler));
    if (FAILED(hr))
    {
        MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to initialise the DxC compiler");
        return false;

    }

    hr = m_dxcUtils->CreateDefaultIncludeHandler(&m_includeHandler);
    if (FAILED(hr))
    {
        MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to initialise the default include handler");

    }

    return true;
}

///-----------------------------------------------------------------------------
///! @brief   
///! @remark shaderCodeBuffer, length, m_fileName.c_str(), 0, D3D_COMPILE_STANDARD_FILE_INCLUDE, m_entryPoint.c_str(), profileName.c_str(), shaderCompilerFlags
///-----------------------------------------------------------------------------
bool ShaderCompiler::CreateShader(const std::filesystem::path& filePath, const std::wstring& entrypoint, const std::wstring& profileName, size_t compilerFlags, bool createRootDescriptor, CreatedShaderObjects& shaderObject) const
{
    PROFILE_FUNCTION();
    UNUSEDPARAM(compilerFlags);
    std::string OptickTagName = "ShaderCompiler::CreateShader " + filePath.string();
    OPTICK_EVENT_DYNAMIC(OptickTagName.c_str());
    //std::string fileName = filePath.string();
    //OPTICK_TAG("CreateShader: ", fileName.c_str());
    uint32_t codePage = CP_UTF8;
    IDxcBlobEncoding* shaderSourceFromFile = nullptr;
    const std::wstring& wideFilePath = filePath.wstring();
    HRESULT hr = m_dxcUtils->LoadFile(wideFilePath.c_str(), &codePage, &shaderSourceFromFile);
    if (FAILED(hr))
    {
        MSG_TRACE_CHANNEL("Shaders", "Failed to load shader file: %s", filePath.c_str());
        return false;
    }

    DxcBuffer shaderSourceCode;
    shaderSourceCode.Ptr = shaderSourceFromFile->GetBufferPointer();
    shaderSourceCode.Size = shaderSourceFromFile->GetBufferSize();
    shaderSourceCode.Encoding = DXC_CP_ACP; //BOM UTF8, UTF16 or ANSI

    std::filesystem::path shadersPath = filePath.parent_path();
    const std::wstring& shaderPathWide = shadersPath.wstring();

    std::vector<LPCWSTR> arguments =
    {
        wideFilePath.c_str(),          // Optional shader source file name for error reporting and for PIX shader source view.
        L"-I", shaderPathWide.c_str(), //Include path.
        L"-E", entrypoint.c_str(),     // Entry point.
        L"-T", profileName.c_str(),    // Target.
        L"-Zs", L"-Zpr",               // Enable debug information (slim format), enable row major
        L"-Fo", L"myshader.bin",       // Optional. Stored in the pdb. 
        L"-Fd", L"myshader.pdb",       // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
        L"-Qstrip_reflect",            // Strip reflection into a separate blob. 
        L"-HV", L"2021"                // Enable templates in shaders
    };

    IDxcResult* results = nullptr;
    {
        PROFILE_TAG("Compile Shader");
        hr = m_compiler->Compile(&shaderSourceCode, arguments.data(), static_cast<UINT>(arguments.size()), m_includeHandler, IID_PPV_ARGS(&results));
    }

    //
   // Print errors if present.
   //
    IDxcBlobUtf8* errors = nullptr;
    results->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&errors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.
    // IDxcCompiler3::Compile will always return an error buffer, but its length
    // will be zero if there are no warnings or errors.
    if (errors != nullptr && errors->GetStringLength() != 0)
    {
        MSG_TRACE_CHANNEL("ShaderCompiler", "Compiler Errors/Warnings Output: %s", errors->GetStringPointer());
    }

    HRESULT hrStatus;
    results->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to compile shader: %s", filePath.string().c_str());
        return false;
    }

    ////
    //// Demonstrate getting the hash from the PDB blob using the IDxcUtils::GetPDBContents API
    ////
    //CComPtr<IDxcBlob> pHashDigestBlob = nullptr;
    //CComPtr<IDxcBlob> pDebugDxilContainer = nullptr;
    //if (SUCCEEDED(pUtils->GetPDBContents(pPdb, &pHashDigestBlob, &pDebugDxilContainer)))
    //{
    //    // This API returns the raw hash digest, rather than a DxcShaderHash structure.
    //    // This will be the same as the DxcShaderHash::HashDigest returned from
    //    // IDxcResult::GetOutput(DXC_OUT_SHADER_HASH, ...).
    //    wprintf(L"Hash from PDB: ");
    //    const BYTE* pHashDigest = (const BYTE*)pHashDigestBlob->GetBufferPointer();
    //    assert(pHashDigestBlob->GetBufferSize() == 16); // hash digest is always 16 bytes.
    //    for (int i = 0; i < pHashDigestBlob->GetBufferSize(); i++)
    //        wprintf(L"%.2x", pHashDigest[i]);
    //    wprintf(L"\n");

    //    // The pDebugDxilContainer blob will contain a DxilContainer formatted
    //    // binary, but with different parts than the pShader blob retrieved
    //    // earlier.
    //    // The parts in this container will vary depending on debug options and
    //    // the compiler version.
    //    // This blob is not meant to be directly interpreted by an application.
    //}

    //
    // Get separate reflection.
    //
    {
        PROFILE_TAG("Reflect Shader");
        IDxcBlob* reflectionData;
        results->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&reflectionData), nullptr);
        if (reflectionData != nullptr)
        {
            // Optionally, save reflection blob for later here.

            // Create reflection interface.
            DxcBuffer ReflectionData;
            ReflectionData.Encoding = DXC_CP_ACP;
            ReflectionData.Ptr = reflectionData->GetBufferPointer();
            ReflectionData.Size = reflectionData->GetBufferSize();

            m_dxcUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(&shaderObject.m_reflectionObject));
            if (FAILED(hr))
            {
                MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to get reflection object for: %s", filePath.string().c_str());
                shaderObject.m_reflectionObject = nullptr;
                return false;
            }

            // Use reflection interface here.

        }
    }

    if (createRootDescriptor)
    {
        {
            PROFILE_TAG("Create RootSignature");
            hr = results->GetOutput(DXC_OUT_ROOT_SIGNATURE, IID_PPV_ARGS(&shaderObject.m_rootSignatureBlob), nullptr);
            if (FAILED(hr))
            {
                MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to get compiled root signature for: %s", filePath.string().c_str());
                shaderObject.m_rootSignatureBlob = nullptr;
                return false;
            }
        }
    }

    {
        PROFILE_TAG("Get Compiled Shader");
        hr = results->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderObject.m_shaderObject), nullptr);
        if (FAILED(hr))
        {
            MSG_TRACE_CHANNEL("ShaderCompiler", "Failed to get compiled shader object for: %s", filePath.string().c_str());
            shaderObject.m_shaderObject = nullptr;
            return false;
        }
    }
    
    WriteDataToFileCache(results);

    return true;
}

void ShaderCompiler::WriteDataToFileCache(IDxcResult* compileResult) const
{
    ////
    //// Print hash.
    ////
    IDxcBlob* pHash = nullptr;
    compileResult->GetOutput(DXC_OUT_SHADER_HASH, IID_PPV_ARGS(&pHash), nullptr);
    std::stringstream shaderHash;
    if (pHash != nullptr)
    {
        DxcShaderHash* pHashBuf = (DxcShaderHash*)pHash->GetBufferPointer();
        for (int i = 0; i < _countof(pHashBuf->HashDigest); i++)
            shaderHash << std::hex << pHashBuf->HashDigest[1]; // wprintf(L"%.2x", pHashBuf->HashDigest[i]);
        //wprintf(L"\n");
        MSG_TRACE_CHANNEL("ShaderCompiler", "Shader hash is: %x", shaderHash.str().c_str());
    }

    auto csoFileName = fmt::format("{}{}", shaderHash.str(), ".cso");
    std::filesystem::path outputPath = m_resource->m_paths->getTempPath() / csoFileName;
    VFS::FileSystem* fileSystem = m_resource->m_fileSystem;

    //Write output to a file
    IDxcBlob* pShader = nullptr;
    IDxcBlobUtf16* pShaderName = nullptr;
    compileResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
    if (pShader != nullptr)
    {
        VFS::File csoFile = fileSystem->CreateFile(outputPath, VFS::FileMode::OpenAndCreate);
        csoFile.Write(static_cast<byte*>(pShader->GetBufferPointer()), pShader->GetBufferSize());
        csoFile.Close();
    }


 
    //
    // Save pdb.
    //
    IDxcBlob* pPDB = nullptr;
    IDxcBlobUtf16* pPDBName = nullptr;
    compileResult->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
    {
        //modify the output path to the pdb path
        auto pdbFileName = fmt::format("{}{}", shaderHash.str(), ".pdb");
        outputPath = m_resource->m_paths->getTempPath() / pdbFileName;
        VFS::File csoFile = fileSystem->CreateFile(outputPath, VFS::FileMode::OpenAndCreate);
        csoFile.Write(static_cast<byte*>(pPDB->GetBufferPointer()), pPDB->GetBufferSize());
        csoFile.Close();
    }

}

