#include "BindlessBuffers.ifx"
#include "Shared/CommonStructures.h"
#include "rootsignatures.ifx"
#include "Samplers.ifx"

//--------------------------------------------------------------------------------------
// Constant Buffer Variables
//--------------------------------------------------------------------------------------
ConstantBuffer<MeshResourceIndices> resourceIndices : register(b0);

///--------------------------------------------------------------------------------------
struct PS_INPUT
{
    float4 Pos : SV_POSITION;
    float3 Nor : NORMAL0;
    float3 Tan : TANGENT0;
    float3 BiN : BINORMAL0;
    float2 Tex : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
    float4 LightToPixel : TEXCOORD2;
};


// Constant normal incidence Fresnel factor for all dielectrics.
static const float3 Fdielectric = 0.04;

float3 fresnelSchlick(float3 F0, float angleWithHalfVector)
{
    //Fresnel factor
    //Fresnel equation = F0 + (1-F0)(1-(halfvector dot view))^5
    return F0 + (1 - F0) * (pow((1 - angleWithHalfVector), 5));
}

// Calculate normal distribution for specular BRDF.
//Trowbridge-Reitz GGX Normal Distribution Function
float ndfGGX(float angleToHalfVectorSquared, float roughness)
{
    //Roughness distribution function of the surface
    //equation = rouhgness^2 / (pi((n dot halfvector)^2(roughness^2 -1) +1 )^2)
    float roughnessSquared = roughness * roughness;
    return roughnessSquared / (pi * pow(((angleToHalfVectorSquared) * (roughnessSquared - 1) + 1), 2));
}

//Schlick GGX Geometry Approxmiation, base rule, precalculated inputs
// angle = n dot direction to apply
// roughnessFactor = ((roughness + 1) ^ 2) / 8
float schlickGGXGA(float angle, float roughnessFactor)
{
    //Geometric apporximation, takes care of self shadowing
    //equation = (n dot v) / ((n dot v)((1 - (roughness + 1)^2)/8) + ((roughness + 1)^2/8))
    return angle / (angle * (1 - roughnessFactor) + roughnessFactor);
}

// Calculate geometric attenuation for specular BRDF.
float smithsGeoApproximation(float angleWithViewDirection, float angleWithLightDirection, float roughness)
{
    //Light coming form and seen from the eye being blocked
    //equation = schlickGGXGA(normal, view_direction, roughness) * schlickGGXGA(normal, light_direction, roughness)
    float roughnessFactor = pow((roughness + 1), 2) / 8;
    return schlickGGXGA(angleWithLightDirection, roughnessFactor) * schlickGGXGA(angleWithLightDirection, roughnessFactor);
}

///--------------------------------------------------------------------------------------
// Pixel Shader
///--------------------------------------------------------------------------------------
float4 ps_main( PS_INPUT input) : SV_Target
{
    //return float4(1.0, 0.0, 0.0, 1.0);
    float3 vertexPos = input.WorldPos;
    float3 color;

    //Grab textures from the heap
    Texture2D<float4> shaderTextures = GetColorTexture(resourceIndices.albedoMapIndex);
    Texture2D<float4> normalMap = GetNormalTexture(resourceIndices.normalMapIndex);
    Texture2D<float4> shadowMap = GetColorTexture(resourceIndices.shadowMapIndex);
    Texture2D<float4> metalnessMap = GetColorTexture(resourceIndices.metalnessMapIndex); //This and the next one could be one map
	Texture2D<float4> roughnessMap = GetColorTexture(resourceIndices.roughnessMapIndex);
	Texture2D<float4> ambientOcclusionMap = GetColorTexture(resourceIndices.ambientOcclusionMapIndex);
    Texture3D<float4> irradianceMap = GetCubeTexture(resourceIndices.cubeReflectionIndex);

    //Sample Textures and calculate normals
    float3 albedoColor =  shaderTextures.Sample(linearWrapSampler, input.Tex).rgb;
    //texColor = float4(1,1,1,1);
    float3 sampledNormalMap = ((2.0 * normalMap.Sample(linearWrapSampler, input.Tex).xyz) - 1.0);
    float3 nnormal = normalize(input.Tan * sampledNormalMap.x + input.BiN * sampledNormalMap.y + input.Nor * sampledNormalMap.z);
    //nnormal = normalize(input.Nor);
    //Sample textures
    float roughness = roughnessMap.Sample(linearWrapSampler, input.Tex).r;
    float metalness = metalnessMap.Sample(linearWrapSampler, input.Tex).r;

	// Fresnel reflectance at normal incidence (for metals use albedo color).
	float3 F0 = lerp(Fdielectric, albedoColor, metalness);

    //Grab parameters from the heap
    ConstantBuffer<MaterialConstants> material = GetConstantBuffer<MaterialConstants>(resourceIndices.materialIndex);
    ConstantBuffer<LightParameters> lights = GetConstantBuffer<LightParameters>(resourceIndices.LightBufferIndex);
    ConstantBuffer<CameraConstantArray> cameraSettings = GetConstantBuffer<CameraConstantArray>(resourceIndices.CameraBufferIndex);
    uint NumberOfLights = lights.NumberOfLights;

    float3 nviewdirection = normalize(cameraSettings.m_constants[0].m_position - vertexPos);
    float angleWithViewDir = dot(nnormal, nviewdirection);

    //Calculate shadow map sample coords
    float2 shadowMapTex;
    shadowMapTex.x = input.LightToPixel.x / input.LightToPixel.w / 2.0f + 0.5f;
    shadowMapTex.y = -input.LightToPixel.y / input.LightToPixel.w / 2.0f + 0.5f;
    float pixelDepth = input.LightToPixel.z - 0.0025;// / input.LightToPixel.w ;///- 0.005;

    //Ambient and emissive color
    //color = float4(material.ambient.rgb, 1.0) * albedoColor + float4(material.emissive.rgb, 0.0);

    for (int counter = 0; counter < NumberOfLights; ++counter)
    {

        float3 lightDir = lights.m_lights[counter].m_position.xyz - vertexPos;
        float distance = length(lightDir);

        if (distance <= lights.m_lights[counter].m_range.x) //Still assume a range here because it can cut back on distant light calcs
        {
            lightDir = normalize(lightDir);
            float3 halfVector = normalize(lightDir + nviewdirection);
            float angleWithLightDir = dot(nnormal, -lightDir);

            float angleWithHalfVector = dot(nnormal, halfVector);

            // These are the pluggable functions for PBR, F= fresnel, D = specular distribution, G = geometric distribution
            // Calculate Fresnel term for direct lighting. 
            float3 F = fresnelSchlick(F0, max(0.0, dot(halfVector, nviewdirection)));
            // Calculate normal distribution for specular BRDF.
            float D = ndfGGX(angleWithHalfVector, roughness);
            // Calculate geometric attenuation for specular BRDF.
            float G = smithsGeoApproximation(angleWithViewDir, angleWithLightDir, roughness);

            float3 specularColor = (D*F*G) / (4 * (angleWithViewDir) * (angleWithLightDir));
            float3 diffuseColor = lerp(float3(1, 1, 1) - F, float3(0, 0, 0), metalness) * albedoColor; //apply dielectric and metalness and combine with albedo, this takes out albedo on metal parts
            diffuseColor /= pi; //Divid by pi because hemispherical brdf

            color += (diffuseColor + specularColor) * lights.m_lights[counter].m_irradiance.rgb * angleWithLightDir; //irradiance is strength and color of the light here

            //Image based ligthing for ambient term needs cubemaps
            float3 ambientLighting;
            {
                // Sample diffuse irradiance at normal direction.
                float3 irradiance = irradianceMap.Sample(linearWrapSampler, nnormal).rgb;

                // Calculate Fresnel term for ambient lighting.
                // Since we use pre-filtered cubemap(s) and irradiance is coming from many directions
                // use cosLo instead of angle with light's half-vector (cosLh above).
                // See: https://seblagarde.wordpress.com/2011/08/17/hello-world/
                float3 F = fresnelSchlick(F0, angleWithViewDir);

                // Get diffuse contribution factor (as with direct lighting).
                float3 kd = lerp(1.0 - F, 0.0, metalness);

                // Irradiance map contains exitant radiance assuming Lambertian BRDF, no need to scale by 1/PI here either.
                float3 diffuseIBL = kd * albedoColor * irradiance;

                // Sample pre-filtered specular reflection environment at correct mipmap level.
                // uint specularTextureLevels = querySpecularTextureLevels();
                // float3 specularIrradiance = specularTexture.SampleLevel(defaultSampler, Lr, roughness * specularTextureLevels).rgb;

                // // Split-sum approximation factors for Cook-Torrance specular BRDF.
                // float2 specularBRDF = specularBRDF_LUT.Sample(spBRDF_Sampler, float2(cosLo, roughness)).rg;

                // // Total specular IBL contribution.
                // float3 specularIBL = (F0 * specularBRDF.x + specularBRDF.y) * specularIrradiance;

                // // Total ambient lighting contribution.
                // ambientLighting = diffuseIBL + specularIBL;
            }

            //if (counter == 1)
            //{
            //    float4 shadow = shadowMap.Sample(linearWrapSampler, shadowMapTex);
            //    if (pixelDepth < shadow.r)
            //    {
            //        color = doLightCalculation(lights.m_lights[counter], lightDir, nnormal, nviewdirection, distance, material.shininess, material.diffuse, color, texColor);
            //    }
            //}
            //else
            //{
            //    color = doLightCalculation(lights.m_lights[counter], lightDir, nnormal, nviewdirection, distance, material.shininess, material.diffuse, color, texColor);
            //}
        }
    }
    //color.rgb = nnormal;
    //color.a = texColor.a;
    //color = float4(input.Tex, 0,1);
    //color = float4(1,1,1,1);
    //return float4(diffuse.rgb, 1.0);
    return saturate(float4(color,1));
}